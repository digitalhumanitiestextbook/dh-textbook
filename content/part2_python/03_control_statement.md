---
title: 제어문 - 조건문과 반복문
---

<!-- colab-button:start -->
<div class="colab-button">
  <a
    href="https://colab.research.google.com/github/digitalhumanitiestextbook/dh-textbook/blob/main/notebooks/part2_computing/03_network_web_history.ipynb"
    target="_blank"
    rel="noopener"
  >
    Colab에서 실행하기
  </a>
</div>
<!-- colab-button:end -->

## 제어문 - 조건문과 반복문

지난 시간에는 변수, 데이터 타입, 연산자 등 파이썬의 기본 구성 요소를 배웠습니다. 이번 시간에는 이러한 요소들을 조합하여 프로그램의 흐름을 제어하는 '**제어문(Control Flow Statement)**'에 대해 알아봅니다. 

제어문을 사용하면 특정 조건에 따라 다른 코드를 실행하거나, 특정 작업을 반복해서 수행할 수 있습니다. 여기서는 '**조건문(if, elif, else)**'과 '**반복문(for, while)**'을 '프렌즈' 관련 가상 시나리오를 통해 익혀 보겠습니다.


## 상황에 따라 다르게! 조건문 (if, elif, else)

**조건문**은 주어진 조건이 '참(True)'인지 '거짓(False)'인지에 따라 프로그램이 다음에 무엇을 할지 결정하게 해줍니다. "만약 ~라면 이걸 하고, 그렇지 않고 만약 ~라면 저걸 하고, 그 외에는 요걸 해라" 와 같은 논리적 흐름을 만듭니다.

* **`if 조건:`**: '만약 조건이 참(True)이라면' 아래 들여쓰기 된 코드를 실행합니다.
* **`elif 조건:`**: '위의 if(또는 다른 elif) 조건이 거짓이고, 이번 조건이 참(True)이라면' 아래 들여쓰기 된 코드를 실행합니다. `elif`는 여러 개 사용할 수 있습니다.
* **`else:`**: '위의 모든 if 와 elif 조건이 거짓이라면' 아래 들여쓰기 된 코드를 실행합니다. `else`는 선택 사항이며, 가장 마지막에 한 번만 사용할 수 있습니다.


### 대사의 수사적 기능 분류하기

대본 분석에서는 대사가 어떤 기능을 하는지 파악하는 것이 중요합니다. 간단한 구두점이나 특정 표현을 기준으로 대사의 수사적 기능을 추정해 볼 수 있습니다.

'프렌즈'의 가상 대사 한 줄이 `dialogue` 변수에 저장되어 있다고 가정해 봅시다. 

만약 이 대사가 물음표(`?`)로 끝나면 `"질문형 대사입니다."`를 출력하고, 그렇지 않고 만약 느낌표(`!`)를 포함하면 `"감탄 또는 강조형 대사입니다."`를 출력하고, 그렇지 않고 만약 대사 안에 따옴표(" 또는 ')가 포함되어 있으면 `"인용 또는 간접 화법을 포함한 대사입니다."`를 출력하고, 그 외 나머지 경우에는 `"평서문 형태의 대사입니다."`를 출력하는 파이썬 코드를 실행시켜 봅시다.

```
# 가상의 대사를 변수에 저장합니다.
dialogue = "Could I BE wearing any more clothes?!"

# 조건문을 사용하여 대사의 수사적 기능을 추정합니다.
# 문자열 메서드 .endswith()는 특정 문자열로 끝나는지 확인합니다.
# 'in' 연산자는 특정 문자열이 포함되어 있는지 확인합니다.
if dialogue.endswith("?"):
    print("질문형 대사입니다.")
elif "!" in dialogue:
    print("감탄 또는 강조형 대사입니다.")
elif '"' in dialogue or "'" in dialogue:
    print("인용 또는 간접 화법을 포함한 대사입니다.")
else:
    print("평서문 형태의 대사입니다.")
```

**실행 및 설명**

* 결과 확인
    * `감탄 또는 강조형 대사입니다.`
    * 첫 번째 `if` 조건(`dialogue.endswith("?")`)은 `False`입니다.
    * 두 번째 `elif` 조건(`"!" in dialogue`)은 `True`이므로 해당 메시지가 출력되고 조건문이 종료됩니다.
    * `.endswith()` 와 `in` 같은 문자열 관련 기능(메서드, 연산자)과 조건문을 결합하여 텍스트의 특징을 파악할 수 있습니다.
* `dialogue` 변수의 값을 다른 대사("We were on a break!", "He said, 'we need coffee.'", "Is that my sandwich?") 등으로 바꿔 가며 실행해 보고 결과가 어떻게 달라지는지 확인해 봅시다.


## 여러 번 반복해요! 반복문 (for)

**for 반복문**은 리스트(List)나 딕셔너리(Dictionary), 문자열(String)처럼 여러 개의 요소를 순서대로 또는 특정 규칙에 따라 가지고 있는 데이터 구조의 각 요소를 하나씩 꺼내어 특정 작업을 반복적으로 수행할 때 주로 사용하며, 다음과 같은 형태로 나타납니다.

```
for 변수 in 반복_가능한_데이터
    반복할_코드
```

`반복_가능한_데이터`, 가령 리스트, 딕셔너리 등의 데이터에 들어 있는 요소를 하나씩 꺼내어 for 반복문의 '`변수`'에 저장하고, 그 아래 들여 쓰기 된 `반복할_코드`를 각 요소에 대해 반복 실행합니다.


### 캐릭터 관계망 기초 표현하기 (딕셔너리 순회)

그럼 딕셔너리에 저장된 캐릭터 간의 관계 정보를 반복문을 통해 하나씩 출력해 봅시다.

'프렌즈' 주요 캐릭터 간의 핵심 관계를 나타내는 다음의 딕셔너리 `core_relationships`가 있다고 가정해 봅시다. 

```
core_relationships = {
    "모니카": "챈들러 (부부)", 
    "로스": "모니카 (남매)", 
    "레이첼": "로스 (연인/친구)"
    }  # 여러 줄에 걸쳐 작성 가능
```

for 반복문과 `.items()` 메소드를 사용해서 이 딕셔너리의 각 키(Key)-값(Value) 쌍을 `"[캐릭터1]와/과 [관계내용] 관계입니다."` 형식으로 한 줄씩 출력하는 파이썬 코드를 실행시켜 봅시다.

```
# 주요 캐릭터 관계 정보를 딕셔너리로 정의합니다.
core_relationships = {"모니카": "챈들러 (부부)", "로스": "모니카 (남매)", "레이첼": "로스 (연인/친구)"}

print("=== 주요 캐릭터 관계 ===")

# for 반복문과 .items()를 사용하여 딕셔너리의 키와 값을 동시에 순회합니다.
for character1, relationship_info in core_relationships.items():
    # 딕셔너리의 각 키는 character1 변수에, 값은 relationship_info 변수에 할당됩니다.
    print(f"{character1}와/과 {relationship_info} 관계입니다.")
```

**실행 및 설명**

* 결과 확인
    * 딕셔너리 데이터 안에 있는 각 관계 정보가 한 줄씩 출력됩니다.
* 딕셔너리에서 `.items()` 메소드를 사용하면 반복문 내에서 키와 값을 동시에 접근할 수 있습니다. 
    * `for key, value in dictionary.items():` 형태는 딕셔너리 데이터를 처리할 때 매우 자주 사용됩니다. 이는 이후 실습할 인물 관계망 분석의 기초 데이터를 확인하는 과정에서 중요하게 활용됩니다.


## 조건이 만족하는 동안 계속! 반복문 (while)

**while 반복문**은 주어진 **조건이 참(True)인 동안** 아래 들여 쓰기 된 코드를 계속해서 반복 실행하는 문장으로, 다음 예시는 `조건`이 참, 즉 불리언 데이터 타입의 `True`인 동안 `실행할 코드`를 반복하는 while 반복문입니다.

```
while 조건: 
    실행할_코드
```

이때, 만약 조건이 계속해서 참으로 유지되면 반복문은 멈추지 않으며, **조건이 거짓(`False`)이 되어야만** 반복을 멈춥니다. 

즉, `while`문의 조건이 계속 참(True)이면 프로그램이 무한히 반복되는 '**무한 루프(infinite loop)**'가 됩니다. 무한히 반복되는 코드를 의도하는 경우는 드물기에, 무한 루프는 많은 경우 오류를 의미하며, 실행 중인 프로그램을 ‘먹통’ 상태로 만듭니다. 따라서 while 루프를 설계할 때는 빨간 불에 직면한 자동차의 브레이크처럼, **언젠가는 조건이 거짓(`False`)이 되도록 상태를 변경하는 코드가 반드시 필요**합니다.

`for`문이 정해진 횟수나 데이터 목록을 순회하는 데 주로 쓰인다면, `while`문은 특정 조건이 만족될 때까지 반복해야 하는 경우, 예를 들어 특정 상태에 도달할 때까지 시뮬레이션하는 경우 등에 유용합니다.

### 갈등 고조 시뮬레이션하기

두 캐릭터 간의 갈등이 점차 고조되는 과정을 `while` 반복문을 이용해 간단히 시뮬레이션해 봅시다.

다음은 두 캐릭터 간의 가상 갈등 지수를 나타내는 `conflict_level` 변수를 0으로 놓고, 갈등이 최고조에 달하는 지점을 5라고 가정, `climax_level` 변수에 저장한 뒤, while 반복문을 사용해서 `conflict_level`이 `climax_level`보다 낮은 동안 `"갈등 고조 중... (단계: [현재 갈등 지수])"` 메시지를 출력하고, `conflict_level`을 1씩 증가시키는 코드입니다. 

반복이 끝나면 `"갈등 최고조 도달!"`이라는 메시지가 출력됩니다.

```
# 갈등 지수 초기화 및 목표 지점 설정
conflict_level = 0
climax_level = 5

print("=== 갈등 시작 ===")

# while 반복문: conflict_level이 climax_level보다 작은 동안 반복
while conflict_level < climax_level:
    print(f"갈등 고조 중... (단계: {conflict_level})")
    # conflict_level을 1 증가시켜 언젠가 조건이 False가 되도록 함 (무한 루프 방지)
    conflict_level += 1 # conflict_level = conflict_level + 1 과 동일

# 반복문이 종료된 후 실행될 코드 (conflict_level이 5가 되었을 때)
print(f"갈등 최고조 도달! (단계: {conflict_level})")
```

**실행 및 설명**

* 결과 확인
    * 갈등 단계 0부터 4까지 메시지가 출력되고, 마지막에 `"갈등 최고조 도달! (단계: 5)"`가 출력됩니다.
    * `while conflict_level < climax_level:` 조건이 참(`True`)인 동안 루프 안의 코드가 반복됩니다.
        * 루프 안에서 `conflict_level += 1` 코드가 실행될 때마다 `conflict_level` 값이 증가하여, 결국 5가 되면 `conflict_level < climax_level` 조건이 거짓(`False`)이 되어 루프를 빠져나옵니다. 
    * 만약 `conflict_level += 1` 코드가 없다면, `conflict_level`은 영원히 0으로 남아 조건이 항상 `True`가 됩니다. 따라서 무한 루프에 빠지게 되고 프로그램은 끝없이 돌아가게 됩니다.


### 정리
이번 실습에서는 프로그램의 흐름을 제어하는 조건문(if, elif, else)과 반복문(for, while)의 기본적인 사용법을 '프렌즈' 관련 인문학적/문학적 맥락의 예시를 통해 익혔습니다. 

조건문은 상황에 따라 다른 코드를 실행하게 하고, 반복문은 특정 작업을 효율적으로 여러 번 수행하게 해줍니다. 이 두 가지 제어 구조는 앞으로 더 복잡한 데이터 처리 및 분석 작업을 수행하는 데 핵심적인 역할을 할 것입니다.
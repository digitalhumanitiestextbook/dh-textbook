---
title: 정규표현식과 데이터 패턴 탐색
---

<!-- colab-button:start -->
<div class="colab-button">
  <a
    href="https://colab.research.google.com/github/digitalhumanitiestextbook/dh-textbook/blob/main/notebooks/part4_regex/03_regex_advanced.ipynb"
    target="_blank"
    rel="noopener"
  >
    Colab에서 실행하기
  </a>
</div>
<!-- colab-button:end -->

## 정규표현식과 데이터 패턴 탐색

방금 전까지 정규 표현식을 활용해 구조적 데이터를 추출하는 방법을 살펴보았습니다. 그런데 정규 표현식이란 정확히 무엇일까요? 

## 6.1. 정규 표현식 (Regular Expression, RegEx)

정규 표현식(RegEx)은 일정한 규칙을 지닌 문자열을 검색하거나(찾기), 치환하거나, 추출하기 위한 형식 언어입니다. 정규 표현식은 검색 규칙을 정의하는 **리터럴 문자(literal character)**와 특수한 의미를 가진 **메타 문자(metacharacter)**의 조합으로 구성되며, Python에서는 내장 라이브러리인 `re`를 사용하여 정규 표현식을 다룹니다.

```
import re
```

| 함수 | 목적 | 설명 |
| :--- | :--- | :--- |
| `re.search(pattern, string)` | **검색 (Search)** | 문자열 전체를 검색하여 패턴과 **가장 먼저 일치하는 부분**을 찾습니다. 일치 객체(Match object) 반환. |
| `re.findall(pattern, string)` | **모두 찾기 (Find All)** | 문자열 전체에서 패턴과 **일치하는 모든 부분**을 찾아 리스트로 반환합니다. |
| `re.sub(pattern, repl, string)` | **치환 (Substitute)** | 패턴과 일치하는 부분을 `repl` 문자열로 **대체**하여 새로운 문자열을 반환합니다. |

### 6.1.1. 이스케이프 문자를 활용한 특수문자 + 앵커

특정 조건의 문자를 '선택'하기 위해 사용되는 문자들입니다. 특히 정규 표현식에서는 원(`₩`) 기호와 역슬래쉬(`\`)가 기능적으로 동일하게 사용됩니다. 이 기호는 통상적으로 엔터 키 바로 윗쪽에 위치하고 있습니다.

정규 표현식에서 이스케이프 문자(`\`)와 앵커(`^`, `\$`)는 특정 조건의 문자를 효율적으로 '선택'하기 위한 메타 문자입니다. 정규 표현식 구문에서 ₩와 역슬래쉬(\)는 기능적으로 동일하게 취급됩니다.

#### 특수 문자 (이스케이프 시퀀스)

이스케이프 시퀀스는 특정 종류의 문자에 일치하는 **특수 문자 클래스** 역할을 합니다.

| 기호 | 의미 | 예시 (Python Pattern) | 불가능 |
| :--- | :--- | :--- | :--- |
| `\t` | **탭 문자** | `r'\t'` | t (영문 소문자) |
| `\n` or `\r` | **개행 문자** | `r'\n'` or `r'\r'` | n or r (영문 소문자) |
| `\d` | **모든 숫자** (= `[0-9]`) | `r'\d'` | 알파벳, 한글, 공백, 특수문자 등 |
| `\D` | **숫자 제외 모든 문자** (= `[^0-9]`) | `r'\D'` | 0, 1, 2, 3, 4, 5, 7 등 모든 숫자 |
| `\s` | **공백 문자** (띄어쓰기, 개행 등) | `r'\s'` | 알파벳, 한글, 숫자, 특수문자 등 |
| `\S` | **공백 문자 아닌 모든 문자** (1개) | `r'\S'` | 띄어쓰기, 개행 등 공백 |

* **탭 문자** (`\t`): 수평 탭 문자(Horizontal Tab) 자체에 일치하며 , 단순한 영문 소문자 't'와는 구분됩니다.
* **개행 문자** (`\n` 또는 `\r`): 줄 바꿈을 나타내는 개행 문자(Newline 또는 Carriage Return) 자체에 일치하며 , 단순한 영문 소문자 'n'이나 'r'과는 다릅니다.
* **모든 숫자** (`\d`): [0-9]와 동일한 의미를 가지며 , 0, 1, 2, 3, 4, 5, 7 등 모든 아라비아 숫자에 일치합니다. 알파벳, 한글, 공백, 특수문자 등 숫자 외의 문자에는 일치하지 않습니다.
* **숫자 제외 모든 문자** (`\D`): [^0-9]와 동일한 의미를 가지며 , 알파벳, 한글, 공백, 특수문자 등 모든 숫자를 제외한 문자에 일치합니다. 당연히 0, 1, 2 등의 숫자에는 일치하지 않습니다.
* **공백 문자** (`\s`): 띄어쓰기, 탭, 개행 등 모든 종류의 공백 문자에 일치합니다. 알파벳, 한글, 숫자, 특수문자 등에는 일치하지 않습니다.
* **공백 문자 아닌 모든 문자** (`\S`): 공백 문자를 제외한 모든 문자에 일치합니다. 띄어쓰기나 개행 등의 공백에는 일치하지 않습니다.

#### 앵커 (Anchor)

앵커는 문자열 **위치(Position)**에 일치하는 메타 문자이며, 특정 문자에 일치하지 않습니다.

| 기호 | 의미 | 예시 (Python Pattern) | 불가능 |
| :--- | :--- | :--- | :--- |
| `^` | **행의 처음** | `r'^[A-Z]'` | 소문자나 한글로 시작하는 i, 나 등 |
| `$` | **행의 끝** | `r'[^.]\$'` | 문장 끝에 있는 마침표(`.`) |


* **행의 처음** (`^`): 패턴이 반드시 텍스트 행의 시작 부분에 위치해야 함을 나타냅니다. 예를 들어, `^[A-Z]`는 행의 시작이 대문자 알파벳인 경우(예: I, Y)에만 일치하며 , 소문자나 한글로 시작하는 경우에는 일치하지 않습니다.
* **행의 끝** (`$`): 패턴이 텍스트 행의 끝 부분에 위치해야 함을 나타냅니다. 예를 들어, `[^₩.]$`는 문장의 끝이 마침표(`.`)로 끝나지 않은 경우(예: ?로 끝나는 문장)에 일치하며 , 문장 끝에 있는 마침표(`.`) 자체에는 일치하지 않습니다.

#### CR과 LF 문자: 타자기 시절의 유산

개행을 나타내는 CR과 LF 문자는 컴퓨터가 아닌 **타자기 시절**의 유산에서 비롯되었습니다.

* **CR (Carriage Return)**: 현재 커서의 위치에서 **맨 앞으로 이동**하는 동작입니다. (타자기에서 캐리지(용지 뭉치)를 오른쪽 끝에서 왼쪽으로 되돌리는 동작에 해당합니다.)
* **LF (Line Feed)**: 커서는 그대로 있고, **줄만 바꾸는** 동작입니다. (타자기에서 용지를 한 줄 올리는 동작에 해당합니다.)
* **CRLF**는 이 두 동작, CR과 LF의 **조합**입니다.

운영체제마다 이 줄바꿈 기호를 다르게 사용합니다.

* **Windows**: CR+LF (`\r\n`)를 사용합니다.
* **Unix 계열** (Linux, macOS 포함): LF(`\n`)를 사용합니다.
* **Mac**: Mac OS X 이전 버전은 CR(`\r`)을 사용했으나 , 이후 Macintosh는 LF(`\n`)를 사용합니다.

### 6.1.2. 논리합 (|), 그룹 묶기 (()), 수량 한정자 (Quantifier)

정규 표현식은 논리합(`|`), 그룹 묶기(`()`), 그리고 수량 한정자를 통해 복잡한 패턴을 정의합니다.

| 기호 | 의미 | 예시 (Python Pattern) | 예시 결과 | 불가능 |
| :--- | :--- | :--- | :--- | :--- |
| `|` | OR (논리합) | `r'나의|너의'` | 나의, 너의 | 나는, 그의 |
| `()` | 그룹 | `r'(나|너|그)의'` | 나의, 너의, 그의 | 나는, 그, 너로 |
| `.` | 공백 포함 모든 문자 (1개) | `r'A.C'` | AAC, AQC, A 5C 등 | A BC (2개 문자) |
| `?` | 0 or 1 | `r'인생.? 기억한다'` | "인생 기억한다", "인생을 기억한다" | "인생 첫 순간을 생생하게 기억한다" |
| `*` | 0개 이상 | `r'인생.* 기억한다'` | "인생 기억한다", "인생을 기억한다", "인생 첫 순간을 생생하게 기억한다" | |
| `+` | 1개 이상 | `r'인생.+ 기억한다'` | "인생을 기억한다", "인생 첫 순간을 생생하게 기억한다" | "인생 기억한다" |
| `\{min, max\}` | N번 이상, N번 이하 일치 | `r'생\{1,3\}'` | 생, 생생, 생생생 | 생생생생 |
| `\{min,\}` | N번 이상 일치 | `r'생\{2,\}'` | 생생, 생생생 | 생 |
| `\{N\}` | N번 일치 | `r'생\{2\}'` | 생생 | 생, 생생생 |

* **논리합(`|`)**: 두 개 이상의 패턴 중 하나에 일치할 때 사용됩니다 (예: 나의|너의는 "나의" 또는 "너의"를 찾습니다).
* **그룹 묶기(`()`)**: 여러 문자를 하나의 단위로 묶어 수량 한정자를 적용하거나, 찾은 패턴을 \1, \2, \3 등의 변수로 참조하여 대체 작업 등에 활용할 수 있게 합니다.
* **수량 한정자(Quantifier)**: 바로 앞의 문자가 몇 번 반복되어야 패턴에 일치하는지를 조건화합니다.
    * `?`: 앞 문자가 0번 또는 1번 나올 때 일치합니다 (선택적).
    * `*`: 앞 문자가 0개 이상 반복될 때 일치합니다.
    * `+`: 앞 문자가 1개 이상 반복될 때 일치합니다.
    * `{N}`: 앞 문자가 정확히 N번 일치해야 합니다.
    * `{min, max}`: 앞 문자가 최소 min회, 최대 max회 일치해야 합니다.

특히, `*`와 `+`는 기본적으로 탐욕적(Greedy) 속성을 가지므로 가능한 가장 긴 문자열에 일치하려 합니다. 패턴 뒤에 `?`를 추가하여 게으른(Lazy) 수량 한정자(`*?`, `+?`)로 만들면, 가능한 가장 짧은 문자열에 일치하게 할 수 있는데, 보다 자세한 내용은 뒤에서 살펴보도록 하겠습니다.

### 6.1.3. 문자 클래스 (Character Class)

문자 클래스는 특정한 문자(알파벳, 한글, 한자 등)를 찾기 위한 문자들로, 대괄호([])를 사용해 정의합니다. 대괄호 안에 나열된 문자들 중 어떤 문자든 하나에 일치하는 패턴을 정의하는 데 사용됩니다. 이는 특정한 문자 그룹(알파벳, 숫자, 한글 등)을 찾기 위한 필수적인 기능입니다.

| 기호 | 의미 | 예시 (Python Pattern) | 예시 결과 | 불가능 |
| :--- | :--- | :--- | :--- | :--- |
| `[]` | 범위 안의 모든 문자 | `r'[1-9]'` | 1, 2, 3, 4, 5 | 0 |
| `[^]` | 범위 안의 문자를 제외한 나머지 | `r'[^a-z]'` | 1 (숫자), L (대문자), 한글 | 영문 소문자 |
| `[A-Za-z]` | 모든 알파벳 | `r'[A-Za-z]'` | A or b 등 모든 알파벳 | 한글, 숫자, 공백, 특수문자 등 |
| `[0-9]` | 모든 숫자 | `r'[0-9]+'` | 0, 1, 2, 3, 4, 5, 7 등 모든 숫자 | 알파벳, 한글, 공백, 특수문자 등 |
| `[가-힣]` | 완전한 한글 | `r'[가-힣]'` | 나 or 난 등 완전한 한글 | ㅎ 등 자음, 모음, 숫자, 알파벳, 공백, 특수문자 등 |
| `[ㄱ-ㅎㅏ-ㅣ가-힣]` | 모든 한글 (자음, 모음 포함) | `r'[ㄱ-ㅎㅏ-ㅣ가-힣]'` | ㅎ 등 모든 한글 | 숫자, 알파벳, 공백, 특수문자 등 |


#### 범위 지정 (`-`)
하이픈(`-`)을 사용하여 문자 범위(`[시작문자-끝문자]`)를 지정하면 해당 범위 내의 모든 문자에 일치시킬 수 있습니다.

* **숫자 범위**: `[0-9]`는 모든 숫자를 의미합니다. `[1-9]`는 `0`을 제외한 $\text{1}$부터 $\text{9}$까지의 숫자에 일치합니다.
* **알파벳 범위**: `[a-z]`는 소문자 전체, `[A-Z]`는 대문자 전체를 의미하며, `[A-Za-z]`는 모든 대소문자 알파벳에 일치합니다.

#### 부정 (`[^]`)
문자 클래스 내에서 캐럿(`^`)이 가장 앞에 위치하면, 그 뒤에 나열된 **문자를 제외한 모든 문자**에 일치하게 됩니다.

* 예시로 `[^a-z]`는 영문 소문자를 제외한 모든 문자(숫자 $\text{1}$, 대문자 $\text{L}$, 한글 등)를 찾습니다.

#### 한글 찾기 (Unicode 기반)
한글의 경우 유니코드(Unicode) 순서를 기반으로 범위를 지정합니다.

* **완전한 한글 (음절)**: `[가-힣]`은 초성, 중성, 종성이 결합된 완성형 한글에만 일치합니다. 이는 문장에서 의미를 가지는 단위를 찾는 데 유용합니다.
* **모든 한글 (자모 포함)**: `[ㄱ-ㅎㅏ-ㅣ가-힣]`은 완성된 한글 음절뿐만 아니라, 자음(ㄱ, ㅎ 등)이나 모음(ㅏ, ㅣ 등)이 분리된 상태까지 모두 포함하여 모든 한글 문자에 일치합니다.
* **한자**: 한자를 찾기 위한 공식적인 문자 클래스 범위도 존재하는데, 일반 한자(CJK)의 경우 `[一-豈-龐]`와 같은 복잡한 유니코드 범위로 지정할 수 있습니다.

이러한 문자 클래스를 사용하면 텍스트 데이터에서 원하는 유형의 문자(예: 이메일 주소의 알파벳, 전화번호의 숫자 등)를 정확하게 구분하고 추출할 수 있습니다.


## 6.2. 정규 표현식 실습: TEI XML 데이터 처리

이전 장에서 구조적 데이터를 추출하고 데이터를 정제하여 xml 데이터를 다음과 같은 형식으로 바꾸어 보았습니다.

```
   episode scene   speaker                                               line     stage inline_stage
0        1     1    Monica  내 생각에 저 남자가 저 여자한테 큰 파이프 오르간을 사줬는데, 여자가 그걸 별로 ...      None           
1        1     1  Chandler                         참치 샐러드 할래? 계란 샐러드 할래? 결정해!   등장인물들처럼           
2        1     1      Ross                            난 Christine이 시키는 걸로 할게.   낮은 목소리로           
3        1     1    Rachel  아빠, 나 그냥... 그 사람과 결혼 못 하겠어! 미안해. 그 사람을 사랑하지 않아...   전화 통화 중           
4        1     1    Phoebe                             내가 머리를 놓으면 머리가 떨어질 거야.      None           
5        1     1  Chandler                                오, 저 바지를 입으면 안 되는데.     TV 보며           
6        1     1      Joey                                  난 계단에서 밀어버리라고 할래.      None           
7        1     1    Phoebe                         계단에서 밀어! 계단에서 밀어! 계단에서 밀어!      None           
8        1     1      Ross                         계단에서 밀어! 계단에서 밀어! 계단에서 밀어!      None           
9        1     1  Chandler                         계단에서 밀어! 계단에서 밀어! 계단에서 밀어!      None           
```

이제 이렇게 데이터프레임에 넣은 데이터를 이용해 정규 표현식을 적용하는 연습을 해 보겠습니다.

#### 6.2.1. 실습: 질문 여부 확인 (is_question)
대사(line)의 끝이 물음표(?)로 끝나는지 여부를 확인합니다.

* 활용 기호: 특수 문자 `\?` (리터럴 물음표), 앵커 `$` (행의 끝)
* 패턴: `r'\?$'`

```
# re.search()를 사용하여 질문 여부를 확인하는 함수
def check_is_question(text):
    # re.search()는 패턴을 찾으면 Match 객체를, 없으면 None을 반환
    if re.search(r'\?$', text.strip()):
        return True
    return False

# 'line' 컬럼에 apply 함수 적용
df['is_question'] = df['line'].apply(check_is_question)

print("### 1. 질문 여부 확인 결과 (is_question) ###")
print(df[['speaker', 'line', 'is_question']].head(4))
```

#### 6.2.2. 실습: 단어 수 세기 (word_count)
`\s` (공백 문자)를 구분자로 사용하여 대사(line)에 포함된 단어의 개수를 계산합니다. 공백이 아닌 문자 덩어리(`\S+`)를 캡처하여 개수를 셉니다.

* 활용 기호: 특수 문자 `\S` (공백 제외 모든 문자), 수량 한정자 `+` (1개 이상)
* 패턴: `r'\S+'`

```
# re.findall을 사용하여 공백이 아닌 문자 덩어리(\S+)를 모두 찾고, 그 개수를 반환
df['word_count'] = df['line'].apply(
    lambda x: len(re.findall(r'\S+', str(x)))
)

print("\n### 2. 단어 수 세기 결과 (word_count) ###")
print(df[['line', 'word_count']].head(5))
```

#### 6.2.3. 실습: 대사 내 임의의 숫자 텍스트 추출 (`extracted_numbers`)
대사 내에 괄호로 묶여 있거나 혹은 독립적으로 나타나는 아라비아 숫자를 모두 추출합니다.

* 활용 기호: 특수 문자 `\d` (모든 숫자), 수량 한정자 `+` (1개 이상), 그룹 `()` (캡처 그룹)
* 패턴: `r'(\d+)'`
 
```
def extract_all_numbers(text):
    # re.findall을 사용하여 모든 숫자 시퀀스 리스트를 찾음
    numbers = re.findall(r'(\d+)', str(text))
    if numbers:
        # 추출된 숫자들을 공백으로 연결하여 문자열로 반환
        return ' '.join(numbers)
    return None

df['extracted_numbers'] = df['line'].apply(extract_all_numbers)

print("\n### 3. 숫자 데이터 추출 결과 (extracted_numbers) ###")
print(df[['line', 'extracted_numbers']].head(7))
```

#### 6.2.4. 실습: 반복 구문 확인 (has_repetition)
대사에서 특정 구문이 3번 이상 연속으로 나타나는지 확인합니다. 이는 감정적인 강조나 추임새의 반복을 분석하는 데 유용합니다.

* 활용 기호: 그룹 `()` (캡처 그룹), 역참조 `\1`, 수량 한정자 `{2,}` (2회 이상 반복), `+?` (비탐욕적)
* 패턴: `r'(.+?)\1{2,}'`

```
# re.search를 사용하여 연속 반복 구문이 있는지 확인하는 함수
df['has_repetition'] = df['line'].apply(
    lambda x: True if re.search(r'(.+?)\1{2,}', str(x)) else False
)

print("\n### 3. 연속 반복 구문 확인 결과 (has_repetition) ###")
print(df[['line', 'has_repetition']].tail(4))
```

그럼 이제 네 가지 실습의 결과를 종합해서 살펴보도록 하겠습니다.

```
print("\n### 최종 DataFrame (4가지 새로운 컬럼 포함) 확인 ###")
print(df[['speaker', 'line', 'is_question', 'word_count', 'extracted_numbers', 'has_repetition']].head(10))
```

| speaker | line | is\_question | word\_count | extracted\_numbers | has\_repetition |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Monica | 내 생각에 저 남자가 저 여자한테 큰 파이프 오르간을 사줬는데, 여자가 그걸 별로... | False | 13 | None | False |
| Chandler | 참치 샐러드 할래? 계란 샐러드 할래? 결정해! | True | 9 | None | False |
| Ross | 난 Christine이 시키는 걸로 할게. | False | 5 | None | False |
| Rachel | 아빠, 나 그냥... 그 사람과 결혼 못 하겠어! 미안해. 그 사람을 사랑하지 않아! | False | 14 | None | False |
| Phoebe | 내가 머리를 놓으면 머리가 떨어질 거야. | False | 7 | None | False |
| Chandler | 오, 저 바지를 입으면 안 되는데. (123) | False | 7 | 123 | False |
| Joey | 난 계단에서 밀어버리라고 할래. | False | 6 | None | False |
| Phoebe | 계단에서 밀어! 계단에서 밀어! 계단에서 밀어! | False | 9 | None | True |
| Ross | 와우! | False | 1 | None | False |
| Chandler | 응, 아 그래. | False | 3 | None | False |

이렇게 정규 표현식을 활용하면 특정한 패턴을 추출하여 새롭게 데이터프레임으로 구성하는 것이 가능합니다.
---
title: 데이터 다운로드 및 탐색
---

<!-- colab-button:start -->
<div class="colab-button">
  <a
    href="https://colab.research.google.com/github/digitalhumanitiestextbook/dh-textbook/blob/main/notebooks/part4_regex/03_regex_advanced.ipynb"
    target="_blank"
    rel="noopener"
  >
    Colab에서 실행하기
  </a>
</div>
<!-- colab-button:end -->

## 데이터 다운로드 및 탐색

> 💡 **인문학적 질문**
>
> "우리의 연구 재료는 어디에 있으며, 어떻게 내 분석 환경으로 가져올 수 있을까요?"

앞서 우리는 데이터를 담는 그릇인 "표(Table)"와 그 표를 자유자재로 다루는 전문 도구 "판다스(Pandas)"에 대해 배웠습니다. 이제 본격적으로 요리를 시작할 시간입니다. 아무리 좋은 그릇과 도구가 있어도, 신선한 재료가 없다면 아무것도 만들 수 없겠죠. 데이터 분석의 세계에서 "재료"는 바로 "데이터"입니다.

이번 섹션에서는 우리 교재의 핵심 재료인 "프렌즈" 대본을 비롯하여, 세상에 흩어져 있는 다양한 형태의 데이터를 우리의 작업 공간인 코랩(Colab)으로 가져오는 여러 가지 방법을 배울 것입니다. 이 과정을 통해 우리는 데이터가 어디에, 어떤 형태로 존재하든 자신감 있게 소환할 수 있는 "데이터 소환술사"로 거듭나게 될 것입니다.

### 3.2.1. [핵심] 연구 데이터의 집결지: GitHub에서 바로 가져오기

오늘날 전 세계의 수많은 개발자와 데이터 과학자들은 자신의 코드와 데이터를 어디에 보관하고 공유할까요? 정답은 바로 "**깃허브(GitHub)**"입니다. 깃허브는 단순히 파일 저장소를 넘어, 협업과 공유, 버전 관리의 중심지로 자리 잡았습니다. 수많은 오픈소스 프로젝트와 공공 데이터, 그리고 학술 연구 데이터가 바로 이곳 깃허브를 통해 공개되고 있습니다.

우리 교재의 핵심 데이터인 "프렌즈" 대본 역시 깃허브에 저장되어 있습니다. 특히 이 데이터는 인문학 분야의 텍스트 데이터를 구조적으로 표현하는 국제 표준인 **TEI(Text Encoding Initiative)** 규약에 따라 XML(eXtensible Markup Language) 형식으로 만들어져 있습니다.

이번 시간에는 이 낯선 XML 파일을 다루는 가장 정석적인 방법을 배워보겠습니다. 바로 **(1) 파일을 내 작업 공간으로 먼저 내려받고, (2) 파일의 속살을 들여다보며 구조를 파악한 뒤, (3) 그 구조에 맞춰 최적의 방법으로 데이터를 불러오는** 3단계의 여정입니다.

---

### **1단계: 데이터 내려받기 (Download)**

가장 먼저 할 일은 인터넷 저편에 있는 XML 파일을 내 작업 공간인 코랩으로 가져오는 것입니다. 웹에 있는 파일을 가져올 때는 `requests`라는 아주 유용한 라이브러리를 사용합니다.

**간단 프롬프트:**
> "깃허브 URL에 있는 파일을 다운로드하는 파이썬 코드를 만들어줘."

**상세 프롬프트:**
> "아래 URL에 있는 파일을 "Friends_Korean_TEI.xml"이라는 이름으로 저장하는 파이썬 코드를 만들어줘. `requests` 라이브러리를 사용해줘.
>
> URL: `https://raw.githubusercontent.com/digitalhumanitiestextbook/Applied-DH/refs/heads/main/RAWDATA/Friends_Korean_TEI.xml`"

**(AI 생성 코드 예상 및 함께 검토):**
```python
import requests

# 1. 깃허브에 저장된 XML 파일의 raw URL 주소를 변수에 저장합니다.
url = "https://raw.githubusercontent.com/digitalhumanitiestextbook/Applied-DH/refs/heads/main/RAWDATA/Friends_Korean_TEI.xml"

# 2. requests.get()으로 해당 URL의 내용을 요청합니다.
response = requests.get(url)

# 3. 인코딩이 깨지지 않도록 설정한 뒤, "Friends_Korean_TEI.xml" 파일로 저장합니다.
with open("Friends_Korean_TEI.xml", "w", encoding="utf-8") as f:
    f.write(response.text)

print("파일 다운로드 완료! "Friends_Korean_TEI.xml" 파일이 저장되었습니다.")
```

**실행 및 설명:**
코드를 실행하고 잠시 기다리면, "파일 다운로드 완료!"라는 메시지와 함께 코랩 왼쪽의 파일 탐색기 창에 `Friends_Korean_TEI.xml` 파일이 생성된 것을 확인할 수 있습니다. 이제 재료 손질의 첫 단계가 끝났습니다.

---

### **2단계: 데이터 구조 탐색하기 (Explore)**

파일을 무작정 열기 전에, 내용물이 어떻게 생겼는지 AI와 함께 정찰해 봅시다. 이 과정은 앞으로 우리가 어떤 도구와 방법으로 데이터를 요리해야 할지 결정하는 데 결정적인 단서를 제공합니다.

**간단 프롬프트:**
> "XML 파일의 구조를 분석해줘."

**상세 프롬프트:**
> "방금 다운로드한 "Friends_Korean_TEI.xml" 파일의 내용과 구조를 알려줘. 파일의 앞부분 20줄 정도를 보여주고, 이 데이터가 어떤 태그들로 구성되어 있는지 설명해줘. 특히 대사와 화자 정보가 어떤 태그에 담겨 있는지 알려줘."

**(AI 생성 코드 예상 및 함께 검토):**
AI가 파일의 내부를 정찰하고 다음과 같이 정확한 구조를 보고합니다.

**[AI의 보고 내용]**
"파일을 정밀 분석한 결과, TEI 표준에 따라 매우 체계적으로 구성되어 있음을 확인했습니다."
```xml
<TEI xmlns="[http://www.tei-c.org/ns/1.0](http://www.tei-c.org/ns/1.0)">
... (중략) ...
<text>
  <body>
    <div type="scene" n="1">
      <sp who="#Monica">
        <speaker>MONICA</speaker>
        <p>아무것도 아냐! 그냥... 그냥 어떤 남자야, 직장에서 같이 일하는.</p>
      </sp>
...
```

**실행 및 설명:**
**[구조 분석]**
* **네임스페이스(Namespace):** 파일 최상단에 `xmlns="http://www.tei-c.org/ns/1.0"`라는 중요한 선언이 있습니다. 이는 이 문서의 모든 태그가 "TEI"라는 고유한 소속을 가짐을 의미합니다.
* **핵심 단위:** 한 인물의 대사는 `<sp>` (speech) 태그로 묶여 있습니다. 이 태그는 `who`라는 속성(attribute)을 가집니다.
* **화자 정보:** `<sp>` 태그 바로 아래의 `<speaker>` 태그 안에 화자의 이름이 명확하게 들어있습니다.
* **대사 내용:** `<speaker>` 태그 다음에 오는 `<p>` (paragraph) 태그 안에 실제 대사 내용이 담겨 있습니다.
* **지문 정보:** `<stage>` (stage direction) 태그에는 상황이나 행동을 묘사하는 지문이 들어있습니다. (파일 전체에 걸쳐 나타날 수 있습니다)

이제 우리는 이 데이터의 비밀을 완벽하게 풀었습니다. **"TEI"라는 소속을 가진 `<sp>` 태그를 기준으로, 그 안의 `who` 속성과 `<speaker>`, `<p>`, `<stage>` 태그를 찾아내면 화자, 대사, 지문 정보를 모두 추출할 수 있습니다.** 이 명확한 구조 정보를 가지고 다음 단계로 나아가겠습니다.

---

### **3단계: 데이터 불러오기 (Load)와 예상치 못한 손님**

이제 모든 준비가 끝났습니다. 데이터의 정확한 구조와 "네임스페이스"의 존재를 알고 있으니, 판다스에게 무엇을 어떻게 가져와야 할지 정확하게 지시할 수 있습니다.

**간단 프롬프트:**
> "XML 파일을 판다스 데이터프레임으로 만들어줘."

**상세 프롬프트:**
> "2단계에서 구조를 파악한 "Friends_Korean_TEI.xml" 파일에서, 모든 대사와 그 대사를 말한 화자를 추출해서 판다스 데이터프레임으로 만들어줘. TEI 네임스페이스 문제를 해결해야 해."

**(AI 생성 코드 예상 및 함께 검토):**
```python
import pandas as pd

# 1. 2단계에서 구조를 파악한 로컬 XML 파일을 지정합니다.
file_path = "Friends_Korean_TEI.xml"

# 2. XML 네임스페이스를 정의합니다.
#    TEI 문서의 기본 네임스페이스(xmlns)를 "tei"라는 별명(접두사)에 할당합니다.
namespaces = {"tei": "http://www.tei-c.org/ns/1.0"}

# 3. pandas의 read_xml() 함수를 사용하여 데이터를 불러옵니다.
#    xpath에 네임스페이스 별명을 사용하여 "//tei:sp"와 같이 정확한 주소를 지정해줍니다.
df = pd.read_xml(file_path, xpath="//tei:sp", namespaces=namespaces)

# 4. 컬럼 이름을 더 알아보기 쉽게 "p"를 "line"으로 변경합니다.
df = df.rename(columns={"p": "line"})

# 5. head() 함수로 데이터의 상위 5개 행을 출력하여 확인합니다.
print(df.head())
```

**실행 및 설명:**

**결과 확인:**
| | who | speaker | line | stage |
| :--- | :--- | :--- | :--- | :--- |
| 0 | #Monica | Monica | 내 생각에 저 남자가 저 여자한테 큰 파이프 오르간을 사줬는데, 여자가 그걸 별로 ... | None |
| 1 | #Chandler | Chandler | 참치 샐러드 할래? 계란 샐러드 할래? 결정해! | 등장인물들처럼 |
| 2 | #Ross | Ross | 난 Christine이 시키는 걸로 할게. | 낮은 목소리로 |
| 3 | #Rachel | Rachel | 아빠, 나 그냥... 그 사람과 결혼 못 하겠어! 미안해. 그 사람을 사랑하지 않아... | 전화 통화 중 |
| 4 | #Phoebe | Phoebe | 내가 머리를 놓으면 머리가 떨어질 거야. | None |

**코드 해설 및 새로운 발견:**
* `df = pd.read_xml(file_path, xpath="//tei:sp", namespaces=namespaces)`
    * 이 코드는 우리가 지시한 대로 `tei` 소속의 `<sp>` 태그를 기준으로 데이터를 정확히 가져왔습니다.
    * **새로운 발견:** 여기서 `read_xml` 함수는 우리가 예상했던 것보다 훨씬 더 똑똑하게 작동했습니다. `<sp>` 태그를 하나의 단위로 보고, 그 안에 있는 **모든 자식 태그(`speaker`, `p`, `stage`)와 속성(`who`)을 각각 별도의 열로 자동 변환**해 준 것입니다.
    * 이 덕분에 우리는 화자와 대사뿐만 아니라, 인물의 행동이나 상황을 설명하는 중요한 정보인 **지문(`stage`)** 데이터까지 덤으로 얻게 되었습니다! 지문이 없는 대사의 경우 `None`으로 표시됩니다.
* `df = df.rename(columns={"p": "line"})`
    * `<p>` 태그에서 가져온 열의 이름을 "p"에서 "line"으로 바꿔주어 의미를 더 명확하게 했습니다.

오류를 해결하고, 실제 데이터를 실행해 본 결과 우리는 처음의 목표를 초과 달성했습니다. 단순히 화자와 대사만 추출하는 것을 넘어, 극의 내용을 더 깊이 이해하는 데 도움이 될 "지문" 정보까지 얻게 된 것입니다.

이제 `who`와 `speaker` 처럼 중복되어 보이는 정보와, 앞으로 분석에 어떻게 활용할지 모르는 `stage` 열을 어떻게 다룰지는 다음 "데이터 정제" 챕터에서 본격적으로 고민하게 될 것입니다. 지금은 예상치 못한 데이터를 만났을 때 당황하지 않고, 그 구조를 파악하여 우리에게 유리한 정보로 만드는 경험을 했다는 것 자체가 큰 수확입니다.
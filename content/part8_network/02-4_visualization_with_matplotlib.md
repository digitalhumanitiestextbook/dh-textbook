---
title: Matplotlib으로 첫 네트워크 시각화하기
---

<!-- colab-button:start -->
<div class="colab-button">
  <a
    href="https://colab.research.google.com/github/digitalhumanitiestextbook/dh-textbook/blob/main/notebooks/part8_ai/03_gen_ai_llm.ipynb"
    target="_blank"
    rel="noopener"
  >
    Colab에서 실행하기
  </a>
</div>
<!-- colab-button:end -->

## 2.4. Matplotlib으로 첫 네트워크 시각화하기

"백문이 불여일견(百聞不如一見)"이라는 말이 있습니다. 네트워크 분석에서 **시각화(Visualization)**는 이 격언을 그 어떤 분야보다 극적으로 실현시켜주는 과정입니다. 수많은 노드와 엣지로 구성된 복잡한 데이터 테이블이나 리스트를 응시하는 것만으로는 파악하기 어려운 네트워크의 전체적인 구조, 핵심적인 행위자의 위치, 그룹 간의 관계 등을 한 장의 '그림'으로 직관적으로 이해하게 해줍니다. 시각화는 분석의 초기 단계에서 데이터에 대한 직관을 얻는 탐색의 도구이자, 최종 단계에서 나의 발견을 다른 사람에게 효과적으로 전달하는 설득의 도구입니다.

이번 섹션에서는 파이썬의 가장 대표적인 시각화 라이브러리인 **Matplotlib**과 NetworkX를 연동하여, 우리가 만든 첫 번째 네트워크 그래프를 눈으로 직접 확인하는 짜릿한 경험을 해보겠습니다. NetworkX는 네트워크의 구조를 계산하고 분석하는 데 특화되어 있지만, 그림을 그리는 기능은 Matplotlib이라는 전문 화가의 도움을 받습니다. 우리는 `nx.draw()`라는 간단한 함수를 통해, 이 두 전문가를 함께 일하게 만들 것입니다.

**※ 실습을 위한 준비 (Context Setting)**

이번 2.4절의 모든 코드 역시 2.2절에서 만들었던 가상의 '프렌즈' 그래프 `G`를 그대로 사용합니다. 이전 내용이 지워졌거나 Colab을 새로 시작하셨다면, 아래의 준비 코드를 먼저 실행하여 `G`를 다시 만들어주세요.

(아래 코드를 복사하여 Colab 코드 셀에 붙여넣고 실행하세요.)

```
import networkx as nx

# 1. 빈 그래프 객체 생성
G = nx.Graph()

# 2. 노드 추가
G.add_node("Monica")
character_list = ["Rachel", "Ross", "Chandler", "Joey", "Phoebe"]
G.add_nodes_from(character_list)

# 3. 엣지 추가 (속성 포함)
G.add_edge("Monica", "Rachel", relationship="Childhood Friend")
G.add_edge("Monica", "Phoebe")
G.add_edge("Monica", "Chandler", relationship="Spouse", weight=10)
G.add_edge("Chandler", "Joey", relationship="Roommate")
```


---

### 2.4.1. Matplotlib 라이브러리 불러오기 (import matplotlib.pyplot as plt)

NetworkX를 `nx`라는 별명으로 불러왔듯이, Matplotlib 라이브러리 역시 표준적인 방식으로 불러와야 합니다. Matplotlib는 매우 방대한 기능을 가진 라이브러리인데, 그중에서 우리가 사용할 대부분의 그림 그리기 기능은 `pyplot`이라는 하위 모듈에 모여 있습니다.

파이썬 세계의 모든 데이터 과학자들은 `matplotlib.pyplot`을 `plt`라는 별명으로 불러옵니다. 이는 `nx`만큼이나 강력한 관례입니다.

아래 코드를 실행하여 Matplotlib의 `pyplot`을 우리 작업장으로 불러옵시다.

```
import matplotlib.pyplot as plt
```

이제 우리는 `nx`를 통해 네트워크를 조작하고, `plt`를 통해 그림을 그리고 보여줄 준비를 마쳤습니다.

---

### 2.4.2. 기본 그리기: nx.draw() 함수와 주요 옵션

NetworkX 그래프를 시각화하는 가장 기본이 되는 함수는 `nx.draw()` 입니다. 이 함수에 우리가 만든 그래프 객체 `G`를 전달하는 것만으로도 일단 그림을 그릴 수 있습니다.

아래 코드를 실행해 보세요.

```
nx.draw(G)
```

아마 화면에 점과 선으로 이루어진 무언가가 나타났을 것입니다. 하지만 누가 누구인지 알 수도 없고, 조금 못생겨 보이기까지 합니다. 이것이 바로 아무런 옵션도 지정하지 않은 기본 상태의 그림입니다. 이제 몇 가지 핵심적인 **옵션(parameter)**을 추가하여 이 그림을 더 의미있고 보기 좋게 만들어 보겠습니다.

* **노드 라벨 표시하기: `with_labels=True`**
    가장 시급한 문제입니다. 각 노드가 누구를 나타내는지 이름을 표시해야 합니다. `with_labels` 옵션을 `True`로 설정하면 노드의 이름이 라벨로 표시됩니다.

    아래 코드를 실행해 보세요.

```
    nx.draw(G, with_labels=True)
```

이제 훨씬 알아보기 좋아졌습니다! 각 점이 어떤 캐릭터인지 명확히 보입니다.

* **노드 색상 및 크기 조절: `node_color`, `node_size`**
    기본 노드 색상이 마음에 들지 않는다면 `node_color` 옵션으로 원하는 색을 지정할 수 있습니다. 노드의 크기가 너무 작거나 크다면 `node_size` 옵션에 숫자 값을 주어 조절할 수 있습니다.

    아래 코드는 노드를 하늘색(`skyblue`)으로, 크기는 1500으로 설정하는 예시입니다.

```
    nx.draw(G, with_labels=True, node_color="skyblue", node_size=1500)
```

* **글꼴 관련 옵션: `font_color`, `font_size`, `font_family`**
    노드 라벨의 글씨 색이나 크기도 바꿀 수 있습니다.

```
    nx.draw(G, with_labels=True, node_color="skyblue", node_size=1500, font_color="white", font_size=15)
```

이 외에도 `edge_color`(선 색깔), `width`(선 굵기) 등 다양한 옵션들이 있습니다. 이러한 옵션들을 조합하여 우리는 기본적인 시각화 결과물을 원하는 대로 꾸밀 수 있습니다.

**잠깐! 왜 실행할 때마다 노드 위치가 바뀌나요?**
`nx.draw()` 함수는 기본적으로 '스프링 레이아웃(spring layout)'이라는 물리 시뮬레이션 기반의 알고리즘을 사용합니다. 이는 엣지를 '스프링(용수철)'처럼, 노드를 '서로 밀어내는 자석'처럼 간주하여 가장 안정적인 배치를 찾아가는 방식입니다. 이 과정에 약간의 무작위성이 포함되기 때문에, 실행할 때마다 노드의 위치가 조금씩 바뀔 수 있습니다. 이는 자연스러운 현상입니다.

---

### 2.4.3. 시각화 결과 보기: plt.show()

Colab 환경에서는 `nx.draw()`를 실행하는 것만으로도 그림이 바로 출력되는 경우가 많습니다. 하지만 원래 파이썬에서 시각화 코드를 실행할 때는, "이제까지 준비한 그림을 화면에 최종적으로 보여줘!"라는 명시적인 명령이 필요합니다. 그 역할을 하는 것이 바로 `plt.show()` 입니다.

앞으로는 항상 그림을 그리는 코드 블록의 맨 마지막에 `plt.show()`를 붙여주는 습관을 들이는 것이 좋습니다. 이는 그림이 깔끔하게 마무리되고 출력되는 것을 보장하며, 여러 개의 그림을 연속해서 그릴 때 서로 겹치는 문제를 방지해 줍니다.

아래는 완성된 시각화 코드 블록의 표준적인 형태입니다.

```
nx.draw(G, with_labels=True, node_color="skyblue", node_size=1500)
plt.show()
```

---

### 2.4.4. 간단한 시각화 결과 해석 연습

이제 우리가 그린 첫 번째 네트워크 지도를 보며, 간단한 해석을 시도해 봅시다. 이 그림이 우리가 2.3절에서 숫자로 확인했던 정보와 일치하는지 살펴보는 것입니다.

완성된 시각화 결과물을 보며 다음 질문에 답해 보세요.

* **가장 중심에 있는 것처럼 보이는 노드는 누구인가요?**
    아마도 'Monica'일 것입니다. 여러 개의 선(엣지)이 그녀에게 집중되어 시각적으로도 가장 중심적인 위치를 차지하는 경향이 있습니다.

* **이 시각적 중심성이 우리가 `G.degree()`로 확인했던 '연결 차수'와 일치하나요?**
    네, 일치합니다. 2.3절에서 우리는 `G.degree()`를 통해 'Monica'의 연결 차수가 3으로 가장 높다는 것을 확인했습니다. 시각화는 이 정량적인 데이터를 직관적으로 보여주는 것입니다.

* **다른 노드들과 전혀 연결되지 않고 혼자 떨어져 있는 노드는 누구인가요?**
    'Ross'와 'Joey' 중 엣지를 연결하지 않은 'Ross'가 될 것입니다. (만약 'Chandler'-'Joey' 엣지를 추가하지 않았다면 조이도 떨어져 있을 것입니다.) 이는 그의 연결 차수가 0이라는 사실을 시각적으로 확인시켜 줍니다.

* **우리가 의도적으로 연결했던 관계들이 잘 표현되었나요?**
    그림을 보며 (Monica, Rachel), (Monica, Phoebe), (Monica, Chandler), (Chandler, Joey)가 선으로 연결되어 있는지 눈으로 직접 확인할 수 있습니다.

이처럼 시각화는 복잡한 수치 데이터를 직관적인 패턴으로 변환하여, 우리가 데이터를 올바르게 이해하고 있는지 빠르게 점검하고 새로운 통찰의 실마리를 발견하도록 돕는 강력한 도구입니다.

> **🤖 AI와 함께 탐색하기 #10: AI에게 시각화 코드 요청하기**
>
> **학습 목표:** 자연어 설명을 통해, 자신이 원하는 형태의 시각화 결과물을 만들어내는 구체적인 코드를 AI에게 요청하고 생성하는 '입코딩' 실습을 진행합니다.
>
> **간단 프롬프트:**
> `NetworkX로 그래프 G를 그리는 파이썬 코드를 만들어줘. 노드 라벨도 보이게 해줘.`
>
> **상세 프롬프트:**
> `내가 만든 NetworkX 그래프 G가 있어. 이 그래프를 Matplotlib을 사용해서 시각화하는 코드를 생성해줘. 다음 구체적인 요구사항을 모두 반영해줘:
> 1. 노드에는 라벨이 표시되어야 해.
> 2. 노드의 크기는 2000으로 설정해.
> 3. 노드의 색깔은 'lightgreen'으로 해줘.
> 4. 엣지의 색깔은 'gray'로 설정해.
> 5. 엣지의 너비는 2로 해줘.
> 6. 마지막에는 plt.show()를 꼭 포함해줘.`
>
> **인문학적 프롬프트:**
> `네트워크 시각화에서 '레이아웃 알고리즘'(노드의 위치를 결정하는 규칙)의 선택은 매우 중요해. 우리가 사용한 기본 'spring' 레이아웃은 중심적인 노드를 가운데로 모으는 경향이 있어. 만약 'circular' 레이아웃처럼 모든 노드를 원형으로 배치한다면, 동일한 네트워크 데이터라도 전혀 다르게 보일 거야. 이처럼 레이아웃의 선택이 우리의 '해석'에 어떤 영향을 미칠 수 있을까? 연구자가 의도적으로 또는 비의도적으로 레이아웃을 선택함으로써 어떻게 특정 주장을 강화하거나 약화시킬 수 있는지, 시각화의 '수사학적' 측면에 대해 논해줘.`